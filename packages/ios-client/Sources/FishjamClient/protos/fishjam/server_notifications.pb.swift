// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: fishjam/server_notifications.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines any type of message passed between FJ and server peer
struct Fishjam_ServerMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Fishjam_ServerMessage.OneOf_Content? = nil

  var roomCrashed: Fishjam_ServerMessage.RoomCrashed {
    get {
      if case .roomCrashed(let v)? = content {return v}
      return Fishjam_ServerMessage.RoomCrashed()
    }
    set {content = .roomCrashed(newValue)}
  }

  var peerConnected: Fishjam_ServerMessage.PeerConnected {
    get {
      if case .peerConnected(let v)? = content {return v}
      return Fishjam_ServerMessage.PeerConnected()
    }
    set {content = .peerConnected(newValue)}
  }

  var peerDisconnected: Fishjam_ServerMessage.PeerDisconnected {
    get {
      if case .peerDisconnected(let v)? = content {return v}
      return Fishjam_ServerMessage.PeerDisconnected()
    }
    set {content = .peerDisconnected(newValue)}
  }

  var peerCrashed: Fishjam_ServerMessage.PeerCrashed {
    get {
      if case .peerCrashed(let v)? = content {return v}
      return Fishjam_ServerMessage.PeerCrashed()
    }
    set {content = .peerCrashed(newValue)}
  }

  var componentCrashed: Fishjam_ServerMessage.ComponentCrashed {
    get {
      if case .componentCrashed(let v)? = content {return v}
      return Fishjam_ServerMessage.ComponentCrashed()
    }
    set {content = .componentCrashed(newValue)}
  }

  var authenticated: Fishjam_ServerMessage.Authenticated {
    get {
      if case .authenticated(let v)? = content {return v}
      return Fishjam_ServerMessage.Authenticated()
    }
    set {content = .authenticated(newValue)}
  }

  var authRequest: Fishjam_ServerMessage.AuthRequest {
    get {
      if case .authRequest(let v)? = content {return v}
      return Fishjam_ServerMessage.AuthRequest()
    }
    set {content = .authRequest(newValue)}
  }

  var subscribeRequest: Fishjam_ServerMessage.SubscribeRequest {
    get {
      if case .subscribeRequest(let v)? = content {return v}
      return Fishjam_ServerMessage.SubscribeRequest()
    }
    set {content = .subscribeRequest(newValue)}
  }

  var subscribeResponse: Fishjam_ServerMessage.SubscribeResponse {
    get {
      if case .subscribeResponse(let v)? = content {return v}
      return Fishjam_ServerMessage.SubscribeResponse()
    }
    set {content = .subscribeResponse(newValue)}
  }

  var roomCreated: Fishjam_ServerMessage.RoomCreated {
    get {
      if case .roomCreated(let v)? = content {return v}
      return Fishjam_ServerMessage.RoomCreated()
    }
    set {content = .roomCreated(newValue)}
  }

  var roomDeleted: Fishjam_ServerMessage.RoomDeleted {
    get {
      if case .roomDeleted(let v)? = content {return v}
      return Fishjam_ServerMessage.RoomDeleted()
    }
    set {content = .roomDeleted(newValue)}
  }

  var metricsReport: Fishjam_ServerMessage.MetricsReport {
    get {
      if case .metricsReport(let v)? = content {return v}
      return Fishjam_ServerMessage.MetricsReport()
    }
    set {content = .metricsReport(newValue)}
  }

  var hlsPlayable: Fishjam_ServerMessage.HlsPlayable {
    get {
      if case .hlsPlayable(let v)? = content {return v}
      return Fishjam_ServerMessage.HlsPlayable()
    }
    set {content = .hlsPlayable(newValue)}
  }

  var hlsUploaded: Fishjam_ServerMessage.HlsUploaded {
    get {
      if case .hlsUploaded(let v)? = content {return v}
      return Fishjam_ServerMessage.HlsUploaded()
    }
    set {content = .hlsUploaded(newValue)}
  }

  var hlsUploadCrashed: Fishjam_ServerMessage.HlsUploadCrashed {
    get {
      if case .hlsUploadCrashed(let v)? = content {return v}
      return Fishjam_ServerMessage.HlsUploadCrashed()
    }
    set {content = .hlsUploadCrashed(newValue)}
  }

  var peerMetadataUpdated: Fishjam_ServerMessage.PeerMetadataUpdated {
    get {
      if case .peerMetadataUpdated(let v)? = content {return v}
      return Fishjam_ServerMessage.PeerMetadataUpdated()
    }
    set {content = .peerMetadataUpdated(newValue)}
  }

  var trackAdded: Fishjam_ServerMessage.TrackAdded {
    get {
      if case .trackAdded(let v)? = content {return v}
      return Fishjam_ServerMessage.TrackAdded()
    }
    set {content = .trackAdded(newValue)}
  }

  var trackRemoved: Fishjam_ServerMessage.TrackRemoved {
    get {
      if case .trackRemoved(let v)? = content {return v}
      return Fishjam_ServerMessage.TrackRemoved()
    }
    set {content = .trackRemoved(newValue)}
  }

  var trackMetadataUpdated: Fishjam_ServerMessage.TrackMetadataUpdated {
    get {
      if case .trackMetadataUpdated(let v)? = content {return v}
      return Fishjam_ServerMessage.TrackMetadataUpdated()
    }
    set {content = .trackMetadataUpdated(newValue)}
  }

  var peerAdded: Fishjam_ServerMessage.PeerAdded {
    get {
      if case .peerAdded(let v)? = content {return v}
      return Fishjam_ServerMessage.PeerAdded()
    }
    set {content = .peerAdded(newValue)}
  }

  var peerDeleted: Fishjam_ServerMessage.PeerDeleted {
    get {
      if case .peerDeleted(let v)? = content {return v}
      return Fishjam_ServerMessage.PeerDeleted()
    }
    set {content = .peerDeleted(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case roomCrashed(Fishjam_ServerMessage.RoomCrashed)
    case peerConnected(Fishjam_ServerMessage.PeerConnected)
    case peerDisconnected(Fishjam_ServerMessage.PeerDisconnected)
    case peerCrashed(Fishjam_ServerMessage.PeerCrashed)
    case componentCrashed(Fishjam_ServerMessage.ComponentCrashed)
    case authenticated(Fishjam_ServerMessage.Authenticated)
    case authRequest(Fishjam_ServerMessage.AuthRequest)
    case subscribeRequest(Fishjam_ServerMessage.SubscribeRequest)
    case subscribeResponse(Fishjam_ServerMessage.SubscribeResponse)
    case roomCreated(Fishjam_ServerMessage.RoomCreated)
    case roomDeleted(Fishjam_ServerMessage.RoomDeleted)
    case metricsReport(Fishjam_ServerMessage.MetricsReport)
    case hlsPlayable(Fishjam_ServerMessage.HlsPlayable)
    case hlsUploaded(Fishjam_ServerMessage.HlsUploaded)
    case hlsUploadCrashed(Fishjam_ServerMessage.HlsUploadCrashed)
    case peerMetadataUpdated(Fishjam_ServerMessage.PeerMetadataUpdated)
    case trackAdded(Fishjam_ServerMessage.TrackAdded)
    case trackRemoved(Fishjam_ServerMessage.TrackRemoved)
    case trackMetadataUpdated(Fishjam_ServerMessage.TrackMetadataUpdated)
    case peerAdded(Fishjam_ServerMessage.PeerAdded)
    case peerDeleted(Fishjam_ServerMessage.PeerDeleted)

  #if !swift(>=4.1)
    static func ==(lhs: Fishjam_ServerMessage.OneOf_Content, rhs: Fishjam_ServerMessage.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.roomCrashed, .roomCrashed): return {
        guard case .roomCrashed(let l) = lhs, case .roomCrashed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.peerConnected, .peerConnected): return {
        guard case .peerConnected(let l) = lhs, case .peerConnected(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.peerDisconnected, .peerDisconnected): return {
        guard case .peerDisconnected(let l) = lhs, case .peerDisconnected(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.peerCrashed, .peerCrashed): return {
        guard case .peerCrashed(let l) = lhs, case .peerCrashed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.componentCrashed, .componentCrashed): return {
        guard case .componentCrashed(let l) = lhs, case .componentCrashed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authenticated, .authenticated): return {
        guard case .authenticated(let l) = lhs, case .authenticated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authRequest, .authRequest): return {
        guard case .authRequest(let l) = lhs, case .authRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeRequest, .subscribeRequest): return {
        guard case .subscribeRequest(let l) = lhs, case .subscribeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeResponse, .subscribeResponse): return {
        guard case .subscribeResponse(let l) = lhs, case .subscribeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roomCreated, .roomCreated): return {
        guard case .roomCreated(let l) = lhs, case .roomCreated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roomDeleted, .roomDeleted): return {
        guard case .roomDeleted(let l) = lhs, case .roomDeleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.metricsReport, .metricsReport): return {
        guard case .metricsReport(let l) = lhs, case .metricsReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hlsPlayable, .hlsPlayable): return {
        guard case .hlsPlayable(let l) = lhs, case .hlsPlayable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hlsUploaded, .hlsUploaded): return {
        guard case .hlsUploaded(let l) = lhs, case .hlsUploaded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hlsUploadCrashed, .hlsUploadCrashed): return {
        guard case .hlsUploadCrashed(let l) = lhs, case .hlsUploadCrashed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.peerMetadataUpdated, .peerMetadataUpdated): return {
        guard case .peerMetadataUpdated(let l) = lhs, case .peerMetadataUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trackAdded, .trackAdded): return {
        guard case .trackAdded(let l) = lhs, case .trackAdded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trackRemoved, .trackRemoved): return {
        guard case .trackRemoved(let l) = lhs, case .trackRemoved(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trackMetadataUpdated, .trackMetadataUpdated): return {
        guard case .trackMetadataUpdated(let l) = lhs, case .trackMetadataUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.peerAdded, .peerAdded): return {
        guard case .peerAdded(let l) = lhs, case .peerAdded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.peerDeleted, .peerDeleted): return {
        guard case .peerDeleted(let l) = lhs, case .peerDeleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Defines message groups for which peer can subscribe
  enum EventType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case serverNotification // = 1
    case metrics // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .serverNotification
      case 2: self = .metrics
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .serverNotification: return 1
      case .metrics: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Defines types of tracks being published by peers and component
  enum TrackType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case video // = 1
    case audio // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .video
      case 2: self = .audio
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .video: return 1
      case .audio: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Notification sent when a room crashes
  struct RoomCrashed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when a peer is added
  struct PeerAdded {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var peerID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when a peer is removed
  struct PeerDeleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var peerID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when a peer connects
  struct PeerConnected {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var peerID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when a peer disconnects from FJ
  struct PeerDisconnected {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var peerID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when a peer crashes
  struct PeerCrashed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var peerID: String = String()

    var reason: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when a component crashes
  struct ComponentCrashed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var componentID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Response sent by FJ, confirming successfull authentication
  struct Authenticated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Request sent by peer, to authenticate to FJ server
  struct AuthRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var token: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Request sent by peer to subsribe for certain message type
  struct SubscribeRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var eventType: Fishjam_ServerMessage.EventType = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Response sent by FJ, confirming subscription for message type
  struct SubscribeResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var eventType: Fishjam_ServerMessage.EventType = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when a room is created
  struct RoomCreated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when a room is deleted
  struct RoomDeleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Message containing WebRTC metrics from FJ
  struct MetricsReport {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var metrics: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when the HLS stream becomes available in a room
  struct HlsPlayable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var componentID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when the HLS recording is successfully uploded to AWS S3
  struct HlsUploaded {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when the upload of HLS recording to AWS S3 fails
  struct HlsUploadCrashed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when peer updates its metadata
  struct PeerMetadataUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var peerID: String = String()

    var metadata: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Describes a media track
  struct Track {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var type: Fishjam_ServerMessage.TrackType = .unspecified

    var metadata: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Notification sent when peer or component adds new track
  struct TrackAdded {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var endpointInfo: Fishjam_ServerMessage.TrackAdded.OneOf_EndpointInfo? = nil

    var peerID: String {
      get {
        if case .peerID(let v)? = endpointInfo {return v}
        return String()
      }
      set {endpointInfo = .peerID(newValue)}
    }

    var componentID: String {
      get {
        if case .componentID(let v)? = endpointInfo {return v}
        return String()
      }
      set {endpointInfo = .componentID(newValue)}
    }

    var track: Fishjam_ServerMessage.Track {
      get {return _track ?? Fishjam_ServerMessage.Track()}
      set {_track = newValue}
    }
    /// Returns true if `track` has been explicitly set.
    var hasTrack: Bool {return self._track != nil}
    /// Clears the value of `track`. Subsequent reads from it will return its default value.
    mutating func clearTrack() {self._track = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_EndpointInfo: Equatable {
      case peerID(String)
      case componentID(String)

    #if !swift(>=4.1)
      static func ==(lhs: Fishjam_ServerMessage.TrackAdded.OneOf_EndpointInfo, rhs: Fishjam_ServerMessage.TrackAdded.OneOf_EndpointInfo) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.peerID, .peerID): return {
          guard case .peerID(let l) = lhs, case .peerID(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.componentID, .componentID): return {
          guard case .componentID(let l) = lhs, case .componentID(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _track: Fishjam_ServerMessage.Track? = nil
  }

  /// Notification sent when a track is removed
  struct TrackRemoved {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var endpointInfo: Fishjam_ServerMessage.TrackRemoved.OneOf_EndpointInfo? = nil

    var peerID: String {
      get {
        if case .peerID(let v)? = endpointInfo {return v}
        return String()
      }
      set {endpointInfo = .peerID(newValue)}
    }

    var componentID: String {
      get {
        if case .componentID(let v)? = endpointInfo {return v}
        return String()
      }
      set {endpointInfo = .componentID(newValue)}
    }

    var track: Fishjam_ServerMessage.Track {
      get {return _track ?? Fishjam_ServerMessage.Track()}
      set {_track = newValue}
    }
    /// Returns true if `track` has been explicitly set.
    var hasTrack: Bool {return self._track != nil}
    /// Clears the value of `track`. Subsequent reads from it will return its default value.
    mutating func clearTrack() {self._track = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_EndpointInfo: Equatable {
      case peerID(String)
      case componentID(String)

    #if !swift(>=4.1)
      static func ==(lhs: Fishjam_ServerMessage.TrackRemoved.OneOf_EndpointInfo, rhs: Fishjam_ServerMessage.TrackRemoved.OneOf_EndpointInfo) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.peerID, .peerID): return {
          guard case .peerID(let l) = lhs, case .peerID(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.componentID, .componentID): return {
          guard case .componentID(let l) = lhs, case .componentID(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _track: Fishjam_ServerMessage.Track? = nil
  }

  /// Notification sent when metadata of a multimedia track is updated
  struct TrackMetadataUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String = String()

    var endpointInfo: Fishjam_ServerMessage.TrackMetadataUpdated.OneOf_EndpointInfo? = nil

    var peerID: String {
      get {
        if case .peerID(let v)? = endpointInfo {return v}
        return String()
      }
      set {endpointInfo = .peerID(newValue)}
    }

    var componentID: String {
      get {
        if case .componentID(let v)? = endpointInfo {return v}
        return String()
      }
      set {endpointInfo = .componentID(newValue)}
    }

    var track: Fishjam_ServerMessage.Track {
      get {return _track ?? Fishjam_ServerMessage.Track()}
      set {_track = newValue}
    }
    /// Returns true if `track` has been explicitly set.
    var hasTrack: Bool {return self._track != nil}
    /// Clears the value of `track`. Subsequent reads from it will return its default value.
    mutating func clearTrack() {self._track = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_EndpointInfo: Equatable {
      case peerID(String)
      case componentID(String)

    #if !swift(>=4.1)
      static func ==(lhs: Fishjam_ServerMessage.TrackMetadataUpdated.OneOf_EndpointInfo, rhs: Fishjam_ServerMessage.TrackMetadataUpdated.OneOf_EndpointInfo) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.peerID, .peerID): return {
          guard case .peerID(let l) = lhs, case .peerID(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.componentID, .componentID): return {
          guard case .componentID(let l) = lhs, case .componentID(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _track: Fishjam_ServerMessage.Track? = nil
  }

  init() {}
}

#if swift(>=4.2)

extension Fishjam_ServerMessage.EventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Fishjam_ServerMessage.EventType] = [
    .unspecified,
    .serverNotification,
    .metrics,
  ]
}

extension Fishjam_ServerMessage.TrackType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Fishjam_ServerMessage.TrackType] = [
    .unspecified,
    .video,
    .audio,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Fishjam_ServerMessage: @unchecked Sendable {}
extension Fishjam_ServerMessage.OneOf_Content: @unchecked Sendable {}
extension Fishjam_ServerMessage.EventType: @unchecked Sendable {}
extension Fishjam_ServerMessage.TrackType: @unchecked Sendable {}
extension Fishjam_ServerMessage.RoomCrashed: @unchecked Sendable {}
extension Fishjam_ServerMessage.PeerAdded: @unchecked Sendable {}
extension Fishjam_ServerMessage.PeerDeleted: @unchecked Sendable {}
extension Fishjam_ServerMessage.PeerConnected: @unchecked Sendable {}
extension Fishjam_ServerMessage.PeerDisconnected: @unchecked Sendable {}
extension Fishjam_ServerMessage.PeerCrashed: @unchecked Sendable {}
extension Fishjam_ServerMessage.ComponentCrashed: @unchecked Sendable {}
extension Fishjam_ServerMessage.Authenticated: @unchecked Sendable {}
extension Fishjam_ServerMessage.AuthRequest: @unchecked Sendable {}
extension Fishjam_ServerMessage.SubscribeRequest: @unchecked Sendable {}
extension Fishjam_ServerMessage.SubscribeResponse: @unchecked Sendable {}
extension Fishjam_ServerMessage.RoomCreated: @unchecked Sendable {}
extension Fishjam_ServerMessage.RoomDeleted: @unchecked Sendable {}
extension Fishjam_ServerMessage.MetricsReport: @unchecked Sendable {}
extension Fishjam_ServerMessage.HlsPlayable: @unchecked Sendable {}
extension Fishjam_ServerMessage.HlsUploaded: @unchecked Sendable {}
extension Fishjam_ServerMessage.HlsUploadCrashed: @unchecked Sendable {}
extension Fishjam_ServerMessage.PeerMetadataUpdated: @unchecked Sendable {}
extension Fishjam_ServerMessage.Track: @unchecked Sendable {}
extension Fishjam_ServerMessage.TrackAdded: @unchecked Sendable {}
extension Fishjam_ServerMessage.TrackAdded.OneOf_EndpointInfo: @unchecked Sendable {}
extension Fishjam_ServerMessage.TrackRemoved: @unchecked Sendable {}
extension Fishjam_ServerMessage.TrackRemoved.OneOf_EndpointInfo: @unchecked Sendable {}
extension Fishjam_ServerMessage.TrackMetadataUpdated: @unchecked Sendable {}
extension Fishjam_ServerMessage.TrackMetadataUpdated.OneOf_EndpointInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fishjam"

extension Fishjam_ServerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_crashed"),
    2: .standard(proto: "peer_connected"),
    3: .standard(proto: "peer_disconnected"),
    4: .standard(proto: "peer_crashed"),
    5: .standard(proto: "component_crashed"),
    6: .same(proto: "authenticated"),
    7: .standard(proto: "auth_request"),
    8: .standard(proto: "subscribe_request"),
    9: .standard(proto: "subscribe_response"),
    10: .standard(proto: "room_created"),
    11: .standard(proto: "room_deleted"),
    12: .standard(proto: "metrics_report"),
    13: .standard(proto: "hls_playable"),
    14: .standard(proto: "hls_uploaded"),
    15: .standard(proto: "hls_upload_crashed"),
    16: .standard(proto: "peer_metadata_updated"),
    17: .standard(proto: "track_added"),
    18: .standard(proto: "track_removed"),
    19: .standard(proto: "track_metadata_updated"),
    20: .standard(proto: "peer_added"),
    21: .standard(proto: "peer_deleted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Fishjam_ServerMessage.RoomCrashed?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .roomCrashed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .roomCrashed(v)
        }
      }()
      case 2: try {
        var v: Fishjam_ServerMessage.PeerConnected?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .peerConnected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .peerConnected(v)
        }
      }()
      case 3: try {
        var v: Fishjam_ServerMessage.PeerDisconnected?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .peerDisconnected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .peerDisconnected(v)
        }
      }()
      case 4: try {
        var v: Fishjam_ServerMessage.PeerCrashed?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .peerCrashed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .peerCrashed(v)
        }
      }()
      case 5: try {
        var v: Fishjam_ServerMessage.ComponentCrashed?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .componentCrashed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .componentCrashed(v)
        }
      }()
      case 6: try {
        var v: Fishjam_ServerMessage.Authenticated?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .authenticated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .authenticated(v)
        }
      }()
      case 7: try {
        var v: Fishjam_ServerMessage.AuthRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .authRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .authRequest(v)
        }
      }()
      case 8: try {
        var v: Fishjam_ServerMessage.SubscribeRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .subscribeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .subscribeRequest(v)
        }
      }()
      case 9: try {
        var v: Fishjam_ServerMessage.SubscribeResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .subscribeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .subscribeResponse(v)
        }
      }()
      case 10: try {
        var v: Fishjam_ServerMessage.RoomCreated?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .roomCreated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .roomCreated(v)
        }
      }()
      case 11: try {
        var v: Fishjam_ServerMessage.RoomDeleted?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .roomDeleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .roomDeleted(v)
        }
      }()
      case 12: try {
        var v: Fishjam_ServerMessage.MetricsReport?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .metricsReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .metricsReport(v)
        }
      }()
      case 13: try {
        var v: Fishjam_ServerMessage.HlsPlayable?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .hlsPlayable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .hlsPlayable(v)
        }
      }()
      case 14: try {
        var v: Fishjam_ServerMessage.HlsUploaded?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .hlsUploaded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .hlsUploaded(v)
        }
      }()
      case 15: try {
        var v: Fishjam_ServerMessage.HlsUploadCrashed?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .hlsUploadCrashed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .hlsUploadCrashed(v)
        }
      }()
      case 16: try {
        var v: Fishjam_ServerMessage.PeerMetadataUpdated?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .peerMetadataUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .peerMetadataUpdated(v)
        }
      }()
      case 17: try {
        var v: Fishjam_ServerMessage.TrackAdded?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .trackAdded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .trackAdded(v)
        }
      }()
      case 18: try {
        var v: Fishjam_ServerMessage.TrackRemoved?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .trackRemoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .trackRemoved(v)
        }
      }()
      case 19: try {
        var v: Fishjam_ServerMessage.TrackMetadataUpdated?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .trackMetadataUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .trackMetadataUpdated(v)
        }
      }()
      case 20: try {
        var v: Fishjam_ServerMessage.PeerAdded?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .peerAdded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .peerAdded(v)
        }
      }()
      case 21: try {
        var v: Fishjam_ServerMessage.PeerDeleted?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .peerDeleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .peerDeleted(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .roomCrashed?: try {
      guard case .roomCrashed(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .peerConnected?: try {
      guard case .peerConnected(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .peerDisconnected?: try {
      guard case .peerDisconnected(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .peerCrashed?: try {
      guard case .peerCrashed(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .componentCrashed?: try {
      guard case .componentCrashed(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .authenticated?: try {
      guard case .authenticated(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .authRequest?: try {
      guard case .authRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .subscribeRequest?: try {
      guard case .subscribeRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .subscribeResponse?: try {
      guard case .subscribeResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .roomCreated?: try {
      guard case .roomCreated(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .roomDeleted?: try {
      guard case .roomDeleted(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .metricsReport?: try {
      guard case .metricsReport(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .hlsPlayable?: try {
      guard case .hlsPlayable(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .hlsUploaded?: try {
      guard case .hlsUploaded(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .hlsUploadCrashed?: try {
      guard case .hlsUploadCrashed(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .peerMetadataUpdated?: try {
      guard case .peerMetadataUpdated(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .trackAdded?: try {
      guard case .trackAdded(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .trackRemoved?: try {
      guard case .trackRemoved(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .trackMetadataUpdated?: try {
      guard case .trackMetadataUpdated(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .peerAdded?: try {
      guard case .peerAdded(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .peerDeleted?: try {
      guard case .peerDeleted(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage, rhs: Fishjam_ServerMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.EventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVENT_TYPE_UNSPECIFIED"),
    1: .same(proto: "EVENT_TYPE_SERVER_NOTIFICATION"),
    2: .same(proto: "EVENT_TYPE_METRICS"),
  ]
}

extension Fishjam_ServerMessage.TrackType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRACK_TYPE_UNSPECIFIED"),
    1: .same(proto: "TRACK_TYPE_VIDEO"),
    2: .same(proto: "TRACK_TYPE_AUDIO"),
  ]
}

extension Fishjam_ServerMessage.RoomCrashed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".RoomCrashed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.RoomCrashed, rhs: Fishjam_ServerMessage.RoomCrashed) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.PeerAdded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".PeerAdded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "peer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.peerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    if !self.peerID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.PeerAdded, rhs: Fishjam_ServerMessage.PeerAdded) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.peerID != rhs.peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.PeerDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".PeerDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "peer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.peerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    if !self.peerID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.PeerDeleted, rhs: Fishjam_ServerMessage.PeerDeleted) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.peerID != rhs.peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.PeerConnected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".PeerConnected"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "peer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.peerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    if !self.peerID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.PeerConnected, rhs: Fishjam_ServerMessage.PeerConnected) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.peerID != rhs.peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.PeerDisconnected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".PeerDisconnected"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "peer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.peerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    if !self.peerID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.PeerDisconnected, rhs: Fishjam_ServerMessage.PeerDisconnected) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.peerID != rhs.peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.PeerCrashed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".PeerCrashed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "peer_id"),
    3: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.peerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    if !self.peerID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerID, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.PeerCrashed, rhs: Fishjam_ServerMessage.PeerCrashed) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.peerID != rhs.peerID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.ComponentCrashed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".ComponentCrashed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "component_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.componentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    if !self.componentID.isEmpty {
      try visitor.visitSingularStringField(value: self.componentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.ComponentCrashed, rhs: Fishjam_ServerMessage.ComponentCrashed) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.componentID != rhs.componentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.Authenticated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".Authenticated"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.Authenticated, rhs: Fishjam_ServerMessage.Authenticated) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.AuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".AuthRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.AuthRequest, rhs: Fishjam_ServerMessage.AuthRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.SubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".SubscribeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventType != .unspecified {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.SubscribeRequest, rhs: Fishjam_ServerMessage.SubscribeRequest) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.SubscribeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".SubscribeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventType != .unspecified {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.SubscribeResponse, rhs: Fishjam_ServerMessage.SubscribeResponse) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.RoomCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".RoomCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.RoomCreated, rhs: Fishjam_ServerMessage.RoomCreated) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.RoomDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".RoomDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.RoomDeleted, rhs: Fishjam_ServerMessage.RoomDeleted) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.MetricsReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".MetricsReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metrics.isEmpty {
      try visitor.visitSingularStringField(value: self.metrics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.MetricsReport, rhs: Fishjam_ServerMessage.MetricsReport) -> Bool {
    if lhs.metrics != rhs.metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.HlsPlayable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".HlsPlayable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "component_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.componentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    if !self.componentID.isEmpty {
      try visitor.visitSingularStringField(value: self.componentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.HlsPlayable, rhs: Fishjam_ServerMessage.HlsPlayable) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.componentID != rhs.componentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.HlsUploaded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".HlsUploaded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.HlsUploaded, rhs: Fishjam_ServerMessage.HlsUploaded) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.HlsUploadCrashed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".HlsUploadCrashed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.HlsUploadCrashed, rhs: Fishjam_ServerMessage.HlsUploadCrashed) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.PeerMetadataUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".PeerMetadataUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "peer_id"),
    3: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.peerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    if !self.peerID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerID, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.PeerMetadataUpdated, rhs: Fishjam_ServerMessage.PeerMetadataUpdated) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.peerID != rhs.peerID {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.Track: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".Track"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.Track, rhs: Fishjam_ServerMessage.Track) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.TrackAdded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".TrackAdded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "peer_id"),
    3: .standard(proto: "component_id"),
    4: .same(proto: "track"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.endpointInfo != nil {try decoder.handleConflictingOneOf()}
          self.endpointInfo = .peerID(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.endpointInfo != nil {try decoder.handleConflictingOneOf()}
          self.endpointInfo = .componentID(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._track) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    switch self.endpointInfo {
    case .peerID?: try {
      guard case .peerID(let v)? = self.endpointInfo else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .componentID?: try {
      guard case .componentID(let v)? = self.endpointInfo else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._track {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.TrackAdded, rhs: Fishjam_ServerMessage.TrackAdded) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.endpointInfo != rhs.endpointInfo {return false}
    if lhs._track != rhs._track {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.TrackRemoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".TrackRemoved"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "peer_id"),
    3: .standard(proto: "component_id"),
    4: .same(proto: "track"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.endpointInfo != nil {try decoder.handleConflictingOneOf()}
          self.endpointInfo = .peerID(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.endpointInfo != nil {try decoder.handleConflictingOneOf()}
          self.endpointInfo = .componentID(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._track) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    switch self.endpointInfo {
    case .peerID?: try {
      guard case .peerID(let v)? = self.endpointInfo else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .componentID?: try {
      guard case .componentID(let v)? = self.endpointInfo else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._track {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.TrackRemoved, rhs: Fishjam_ServerMessage.TrackRemoved) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.endpointInfo != rhs.endpointInfo {return false}
    if lhs._track != rhs._track {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_ServerMessage.TrackMetadataUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Fishjam_ServerMessage.protoMessageName + ".TrackMetadataUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_id"),
    2: .standard(proto: "peer_id"),
    3: .standard(proto: "component_id"),
    4: .same(proto: "track"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomID) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.endpointInfo != nil {try decoder.handleConflictingOneOf()}
          self.endpointInfo = .peerID(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.endpointInfo != nil {try decoder.handleConflictingOneOf()}
          self.endpointInfo = .componentID(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._track) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.roomID.isEmpty {
      try visitor.visitSingularStringField(value: self.roomID, fieldNumber: 1)
    }
    switch self.endpointInfo {
    case .peerID?: try {
      guard case .peerID(let v)? = self.endpointInfo else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .componentID?: try {
      guard case .componentID(let v)? = self.endpointInfo else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._track {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fishjam_ServerMessage.TrackMetadataUpdated, rhs: Fishjam_ServerMessage.TrackMetadataUpdated) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.endpointInfo != rhs.endpointInfo {return false}
    if lhs._track != rhs._track {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
