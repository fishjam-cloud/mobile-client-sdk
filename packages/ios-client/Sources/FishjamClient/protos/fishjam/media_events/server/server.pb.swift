// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: fishjam/media_events/server/server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines any type of message sent from Membrane RTC Engine to Peer
public struct Fishjam_MediaEvents_Server_MediaEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Fishjam_MediaEvents_Server_MediaEvent.OneOf_Content? = nil

  public var endpointUpdated: Fishjam_MediaEvents_Server_MediaEvent.EndpointUpdated {
    get {
      if case .endpointUpdated(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.EndpointUpdated()
    }
    set {content = .endpointUpdated(newValue)}
  }

  public var trackUpdated: Fishjam_MediaEvents_Server_MediaEvent.TrackUpdated {
    get {
      if case .trackUpdated(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.TrackUpdated()
    }
    set {content = .trackUpdated(newValue)}
  }

  public var tracksAdded: Fishjam_MediaEvents_Server_MediaEvent.TracksAdded {
    get {
      if case .tracksAdded(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.TracksAdded()
    }
    set {content = .tracksAdded(newValue)}
  }

  public var tracksRemoved: Fishjam_MediaEvents_Server_MediaEvent.TracksRemoved {
    get {
      if case .tracksRemoved(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.TracksRemoved()
    }
    set {content = .tracksRemoved(newValue)}
  }

  public var endpointAdded: Fishjam_MediaEvents_Server_MediaEvent.EndpointAdded {
    get {
      if case .endpointAdded(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.EndpointAdded()
    }
    set {content = .endpointAdded(newValue)}
  }

  public var endpointRemoved: Fishjam_MediaEvents_Server_MediaEvent.EndpointRemoved {
    get {
      if case .endpointRemoved(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.EndpointRemoved()
    }
    set {content = .endpointRemoved(newValue)}
  }

  public var connected: Fishjam_MediaEvents_Server_MediaEvent.Connected {
    get {
      if case .connected(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.Connected()
    }
    set {content = .connected(newValue)}
  }

  public var error: Fishjam_MediaEvents_Server_MediaEvent.Error {
    get {
      if case .error(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.Error()
    }
    set {content = .error(newValue)}
  }

  public var offerData: Fishjam_MediaEvents_Server_MediaEvent.OfferData {
    get {
      if case .offerData(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.OfferData()
    }
    set {content = .offerData(newValue)}
  }

  public var candidate: Fishjam_MediaEvents_Candidate {
    get {
      if case .candidate(let v)? = content {return v}
      return Fishjam_MediaEvents_Candidate()
    }
    set {content = .candidate(newValue)}
  }

  public var sdpAnswer: Fishjam_MediaEvents_Server_MediaEvent.SdpAnswer {
    get {
      if case .sdpAnswer(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.SdpAnswer()
    }
    set {content = .sdpAnswer(newValue)}
  }

  public var vadNotification: Fishjam_MediaEvents_Server_MediaEvent.VadNotification {
    get {
      if case .vadNotification(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.VadNotification()
    }
    set {content = .vadNotification(newValue)}
  }

  public var trackVariantSwitched: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantSwitched {
    get {
      if case .trackVariantSwitched(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.TrackVariantSwitched()
    }
    set {content = .trackVariantSwitched(newValue)}
  }

  public var trackVariantDisabled: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantDisabled {
    get {
      if case .trackVariantDisabled(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.TrackVariantDisabled()
    }
    set {content = .trackVariantDisabled(newValue)}
  }

  public var trackVariantEnabled: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantEnabled {
    get {
      if case .trackVariantEnabled(let v)? = content {return v}
      return Fishjam_MediaEvents_Server_MediaEvent.TrackVariantEnabled()
    }
    set {content = .trackVariantEnabled(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case endpointUpdated(Fishjam_MediaEvents_Server_MediaEvent.EndpointUpdated)
    case trackUpdated(Fishjam_MediaEvents_Server_MediaEvent.TrackUpdated)
    case tracksAdded(Fishjam_MediaEvents_Server_MediaEvent.TracksAdded)
    case tracksRemoved(Fishjam_MediaEvents_Server_MediaEvent.TracksRemoved)
    case endpointAdded(Fishjam_MediaEvents_Server_MediaEvent.EndpointAdded)
    case endpointRemoved(Fishjam_MediaEvents_Server_MediaEvent.EndpointRemoved)
    case connected(Fishjam_MediaEvents_Server_MediaEvent.Connected)
    case error(Fishjam_MediaEvents_Server_MediaEvent.Error)
    case offerData(Fishjam_MediaEvents_Server_MediaEvent.OfferData)
    case candidate(Fishjam_MediaEvents_Candidate)
    case sdpAnswer(Fishjam_MediaEvents_Server_MediaEvent.SdpAnswer)
    case vadNotification(Fishjam_MediaEvents_Server_MediaEvent.VadNotification)
    case trackVariantSwitched(Fishjam_MediaEvents_Server_MediaEvent.TrackVariantSwitched)
    case trackVariantDisabled(Fishjam_MediaEvents_Server_MediaEvent.TrackVariantDisabled)
    case trackVariantEnabled(Fishjam_MediaEvents_Server_MediaEvent.TrackVariantEnabled)

  #if !swift(>=4.1)
    public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.OneOf_Content, rhs: Fishjam_MediaEvents_Server_MediaEvent.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.endpointUpdated, .endpointUpdated): return {
        guard case .endpointUpdated(let l) = lhs, case .endpointUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trackUpdated, .trackUpdated): return {
        guard case .trackUpdated(let l) = lhs, case .trackUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tracksAdded, .tracksAdded): return {
        guard case .tracksAdded(let l) = lhs, case .tracksAdded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tracksRemoved, .tracksRemoved): return {
        guard case .tracksRemoved(let l) = lhs, case .tracksRemoved(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endpointAdded, .endpointAdded): return {
        guard case .endpointAdded(let l) = lhs, case .endpointAdded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endpointRemoved, .endpointRemoved): return {
        guard case .endpointRemoved(let l) = lhs, case .endpointRemoved(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connected, .connected): return {
        guard case .connected(let l) = lhs, case .connected(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offerData, .offerData): return {
        guard case .offerData(let l) = lhs, case .offerData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.candidate, .candidate): return {
        guard case .candidate(let l) = lhs, case .candidate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sdpAnswer, .sdpAnswer): return {
        guard case .sdpAnswer(let l) = lhs, case .sdpAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vadNotification, .vadNotification): return {
        guard case .vadNotification(let l) = lhs, case .vadNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trackVariantSwitched, .trackVariantSwitched): return {
        guard case .trackVariantSwitched(let l) = lhs, case .trackVariantSwitched(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trackVariantDisabled, .trackVariantDisabled): return {
        guard case .trackVariantDisabled(let l) = lhs, case .trackVariantDisabled(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trackVariantEnabled, .trackVariantEnabled): return {
        guard case .trackVariantEnabled(let l) = lhs, case .trackVariantEnabled(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// SCHEMAS
  public struct Track {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var metadataJson: String = String()

    public var simulcastConfig: Fishjam_MediaEvents_Server_MediaEvent.Track.SimulcastConfig {
      get {return _simulcastConfig ?? Fishjam_MediaEvents_Server_MediaEvent.Track.SimulcastConfig()}
      set {_simulcastConfig = newValue}
    }
    /// Returns true if `simulcastConfig` has been explicitly set.
    public var hasSimulcastConfig: Bool {return self._simulcastConfig != nil}
    /// Clears the value of `simulcastConfig`. Subsequent reads from it will return its default value.
    public mutating func clearSimulcastConfig() {self._simulcastConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct SimulcastConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var enabled: Bool = false

      public var enabledVariants: [Fishjam_MediaEvents_Variant] = []

      public var disabledVariants: [Fishjam_MediaEvents_Variant] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _simulcastConfig: Fishjam_MediaEvents_Server_MediaEvent.Track.SimulcastConfig? = nil
  }

  public struct Endpoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointType: String = String()

    public var metadataJson: String = String()

    public var trackIDToTrack: Dictionary<String,Fishjam_MediaEvents_Server_MediaEvent.Track> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct IceServer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var credential: String = String()

    public var urls: [String] = []

    public var username: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sent when metadata of one of the endpoints was updated
  public struct EndpointUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointID: String = String()

    public var metadataJson: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sent when metadata of one of the tracks was updated
  public struct TrackUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointID: String = String()

    public var trackID: String = String()

    public var metadataJson: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///  Sent to informs that one of the peers has added one or more tracks.
  public struct TracksAdded {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointID: String = String()

    public var trackIDToTrack: Dictionary<String,Fishjam_MediaEvents_Server_MediaEvent.Track> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///  Sent to informs that one of the peers has removed one or more tracks.
  public struct TracksRemoved {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointID: String = String()

    public var trackIds: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sent to all peers in the room after a new endpoint was added.
  public struct EndpointAdded {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointID: String = String()

    public var metadataJson: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sent to the peer after connecting to the WebRTC Endpoint.
  public struct Connected {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointID: String = String()

    public var endpointIDToEndpoint: Dictionary<String,Fishjam_MediaEvents_Server_MediaEvent.Endpoint> = [:]

    public var iceServers: [Fishjam_MediaEvents_Server_MediaEvent.IceServer] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sent to all remaining peers in the room after some endpoint was removed.
  public struct EndpointRemoved {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sent to inform that an error occurred on the server providing a message to show
  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sent to inform about the number of audio and video tracks that will be sent from the engine to the peer
  public struct OfferData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var tracksTypes: Fishjam_MediaEvents_Server_MediaEvent.OfferData.TrackTypes {
      get {return _tracksTypes ?? Fishjam_MediaEvents_Server_MediaEvent.OfferData.TrackTypes()}
      set {_tracksTypes = newValue}
    }
    /// Returns true if `tracksTypes` has been explicitly set.
    public var hasTracksTypes: Bool {return self._tracksTypes != nil}
    /// Clears the value of `tracksTypes`. Subsequent reads from it will return its default value.
    public mutating func clearTracksTypes() {self._tracksTypes = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct TrackTypes {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var audio: Int32 = 0

      public var video: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _tracksTypes: Fishjam_MediaEvents_Server_MediaEvent.OfferData.TrackTypes? = nil
  }

  /// Sent after receiving `SdpOffer` from Peer
  public struct SdpAnswer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sdpAnswer: String = String()

    public var midToTrackID: Dictionary<String,String> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sent to inform that the track denoted by `trackId` has changed their voice actiivty
  /// For this notification to work, the server must be configured to use VAD extension
  /// and the sender must support it.
  public struct VadNotification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var trackID: String = String()

    public var status: Fishjam_MediaEvents_Server_MediaEvent.VadNotification.Status = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unspecified // = 0
      case silence // = 1
      case speech // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .silence
        case 2: self = .speech
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .silence: return 1
        case .speech: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// Informs that track's variant has been changed
  public struct TrackVariantSwitched {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointID: String = String()

    public var trackID: String = String()

    public var variant: Fishjam_MediaEvents_Variant = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sent when track's variant has been disabled
  public struct TrackVariantDisabled {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointID: String = String()

    public var trackID: String = String()

    public var variant: Fishjam_MediaEvents_Variant = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Sent when track's variant has been enabled
  public struct TrackVariantEnabled {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpointID: String = String()

    public var trackID: String = String()

    public var variant: Fishjam_MediaEvents_Variant = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Fishjam_MediaEvents_Server_MediaEvent.VadNotification.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Fishjam_MediaEvents_Server_MediaEvent.VadNotification.Status] = [
    .unspecified,
    .silence,
    .speech,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Fishjam_MediaEvents_Server_MediaEvent: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.OneOf_Content: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.Track: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.Track.SimulcastConfig: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.Endpoint: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.IceServer: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.EndpointUpdated: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.TrackUpdated: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.TracksAdded: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.TracksRemoved: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.EndpointAdded: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.Connected: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.EndpointRemoved: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.Error: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.OfferData: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.OfferData.TrackTypes: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.SdpAnswer: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.VadNotification: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.VadNotification.Status: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.TrackVariantSwitched: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.TrackVariantDisabled: @unchecked Sendable {}
extension Fishjam_MediaEvents_Server_MediaEvent.TrackVariantEnabled: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fishjam.media_events.server"

extension Fishjam_MediaEvents_Server_MediaEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_updated"),
    2: .standard(proto: "track_updated"),
    3: .standard(proto: "tracks_added"),
    4: .standard(proto: "tracks_removed"),
    5: .standard(proto: "endpoint_added"),
    6: .standard(proto: "endpoint_removed"),
    7: .same(proto: "connected"),
    8: .same(proto: "error"),
    9: .standard(proto: "offer_data"),
    10: .same(proto: "candidate"),
    11: .standard(proto: "sdp_answer"),
    12: .standard(proto: "vad_notification"),
    13: .standard(proto: "track_variant_switched"),
    14: .standard(proto: "track_variant_disabled"),
    15: .standard(proto: "track_variant_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.EndpointUpdated?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .endpointUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .endpointUpdated(v)
        }
      }()
      case 2: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.TrackUpdated?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .trackUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .trackUpdated(v)
        }
      }()
      case 3: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.TracksAdded?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .tracksAdded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .tracksAdded(v)
        }
      }()
      case 4: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.TracksRemoved?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .tracksRemoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .tracksRemoved(v)
        }
      }()
      case 5: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.EndpointAdded?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .endpointAdded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .endpointAdded(v)
        }
      }()
      case 6: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.EndpointRemoved?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .endpointRemoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .endpointRemoved(v)
        }
      }()
      case 7: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.Connected?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .connected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .connected(v)
        }
      }()
      case 8: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.Error?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .error(v)
        }
      }()
      case 9: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.OfferData?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .offerData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .offerData(v)
        }
      }()
      case 10: try {
        var v: Fishjam_MediaEvents_Candidate?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .candidate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .candidate(v)
        }
      }()
      case 11: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.SdpAnswer?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .sdpAnswer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .sdpAnswer(v)
        }
      }()
      case 12: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.VadNotification?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .vadNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .vadNotification(v)
        }
      }()
      case 13: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantSwitched?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .trackVariantSwitched(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .trackVariantSwitched(v)
        }
      }()
      case 14: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantDisabled?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .trackVariantDisabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .trackVariantDisabled(v)
        }
      }()
      case 15: try {
        var v: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantEnabled?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .trackVariantEnabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .trackVariantEnabled(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .endpointUpdated?: try {
      guard case .endpointUpdated(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .trackUpdated?: try {
      guard case .trackUpdated(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tracksAdded?: try {
      guard case .tracksAdded(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .tracksRemoved?: try {
      guard case .tracksRemoved(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .endpointAdded?: try {
      guard case .endpointAdded(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .endpointRemoved?: try {
      guard case .endpointRemoved(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .connected?: try {
      guard case .connected(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .error?: try {
      guard case .error(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .offerData?: try {
      guard case .offerData(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .candidate?: try {
      guard case .candidate(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .sdpAnswer?: try {
      guard case .sdpAnswer(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .vadNotification?: try {
      guard case .vadNotification(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .trackVariantSwitched?: try {
      guard case .trackVariantSwitched(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .trackVariantDisabled?: try {
      guard case .trackVariantDisabled(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .trackVariantEnabled?: try {
      guard case .trackVariantEnabled(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent, rhs: Fishjam_MediaEvents_Server_MediaEvent) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.Track: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".Track"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metadata_json"),
    2: .standard(proto: "simulcast_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metadataJson) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._simulcastConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.metadataJson.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataJson, fieldNumber: 1)
    }
    try { if let v = self._simulcastConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.Track, rhs: Fishjam_MediaEvents_Server_MediaEvent.Track) -> Bool {
    if lhs.metadataJson != rhs.metadataJson {return false}
    if lhs._simulcastConfig != rhs._simulcastConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.Track.SimulcastConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.Track.protoMessageName + ".SimulcastConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "enabled_variants"),
    3: .standard(proto: "disabled_variants"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.enabledVariants) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.disabledVariants) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.enabledVariants.isEmpty {
      try visitor.visitPackedEnumField(value: self.enabledVariants, fieldNumber: 2)
    }
    if !self.disabledVariants.isEmpty {
      try visitor.visitPackedEnumField(value: self.disabledVariants, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.Track.SimulcastConfig, rhs: Fishjam_MediaEvents_Server_MediaEvent.Track.SimulcastConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.enabledVariants != rhs.enabledVariants {return false}
    if lhs.disabledVariants != rhs.disabledVariants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.Endpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".Endpoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "endpoint_type"),
    3: .standard(proto: "metadata_json"),
    4: .standard(proto: "track_id_to_track"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.endpointType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadataJson) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Fishjam_MediaEvents_Server_MediaEvent.Track>.self, value: &self.trackIDToTrack) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointType.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointType, fieldNumber: 2)
    }
    if !self.metadataJson.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataJson, fieldNumber: 3)
    }
    if !self.trackIDToTrack.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Fishjam_MediaEvents_Server_MediaEvent.Track>.self, value: self.trackIDToTrack, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.Endpoint, rhs: Fishjam_MediaEvents_Server_MediaEvent.Endpoint) -> Bool {
    if lhs.endpointType != rhs.endpointType {return false}
    if lhs.metadataJson != rhs.metadataJson {return false}
    if lhs.trackIDToTrack != rhs.trackIDToTrack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.IceServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".IceServer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credential"),
    2: .same(proto: "urls"),
    3: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.credential) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.urls) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.credential.isEmpty {
      try visitor.visitSingularStringField(value: self.credential, fieldNumber: 1)
    }
    if !self.urls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.urls, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.IceServer, rhs: Fishjam_MediaEvents_Server_MediaEvent.IceServer) -> Bool {
    if lhs.credential != rhs.credential {return false}
    if lhs.urls != rhs.urls {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.EndpointUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".EndpointUpdated"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "metadata_json"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.metadataJson) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.metadataJson.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataJson, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.EndpointUpdated, rhs: Fishjam_MediaEvents_Server_MediaEvent.EndpointUpdated) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.metadataJson != rhs.metadataJson {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.TrackUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".TrackUpdated"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "track_id"),
    3: .standard(proto: "metadata_json"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadataJson) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 2)
    }
    if !self.metadataJson.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataJson, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.TrackUpdated, rhs: Fishjam_MediaEvents_Server_MediaEvent.TrackUpdated) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.trackID != rhs.trackID {return false}
    if lhs.metadataJson != rhs.metadataJson {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.TracksAdded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".TracksAdded"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "track_id_to_track"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Fishjam_MediaEvents_Server_MediaEvent.Track>.self, value: &self.trackIDToTrack) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.trackIDToTrack.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Fishjam_MediaEvents_Server_MediaEvent.Track>.self, value: self.trackIDToTrack, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.TracksAdded, rhs: Fishjam_MediaEvents_Server_MediaEvent.TracksAdded) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.trackIDToTrack != rhs.trackIDToTrack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.TracksRemoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".TracksRemoved"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "track_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.trackIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.trackIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.trackIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.TracksRemoved, rhs: Fishjam_MediaEvents_Server_MediaEvent.TracksRemoved) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.trackIds != rhs.trackIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.EndpointAdded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".EndpointAdded"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "metadata_json"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.metadataJson) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.metadataJson.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataJson, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.EndpointAdded, rhs: Fishjam_MediaEvents_Server_MediaEvent.EndpointAdded) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.metadataJson != rhs.metadataJson {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.Connected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".Connected"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "endpoint_id_to_endpoint"),
    3: .standard(proto: "ice_servers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Fishjam_MediaEvents_Server_MediaEvent.Endpoint>.self, value: &self.endpointIDToEndpoint) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.iceServers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.endpointIDToEndpoint.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Fishjam_MediaEvents_Server_MediaEvent.Endpoint>.self, value: self.endpointIDToEndpoint, fieldNumber: 2)
    }
    if !self.iceServers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.iceServers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.Connected, rhs: Fishjam_MediaEvents_Server_MediaEvent.Connected) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.endpointIDToEndpoint != rhs.endpointIDToEndpoint {return false}
    if lhs.iceServers != rhs.iceServers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.EndpointRemoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".EndpointRemoved"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.EndpointRemoved, rhs: Fishjam_MediaEvents_Server_MediaEvent.EndpointRemoved) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.Error, rhs: Fishjam_MediaEvents_Server_MediaEvent.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.OfferData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".OfferData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracks_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tracksTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tracksTypes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.OfferData, rhs: Fishjam_MediaEvents_Server_MediaEvent.OfferData) -> Bool {
    if lhs._tracksTypes != rhs._tracksTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.OfferData.TrackTypes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.OfferData.protoMessageName + ".TrackTypes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "audio"),
    2: .same(proto: "video"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.audio) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.video) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.audio != 0 {
      try visitor.visitSingularInt32Field(value: self.audio, fieldNumber: 1)
    }
    if self.video != 0 {
      try visitor.visitSingularInt32Field(value: self.video, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.OfferData.TrackTypes, rhs: Fishjam_MediaEvents_Server_MediaEvent.OfferData.TrackTypes) -> Bool {
    if lhs.audio != rhs.audio {return false}
    if lhs.video != rhs.video {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.SdpAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".SdpAnswer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sdp_answer"),
    2: .standard(proto: "mid_to_track_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sdpAnswer) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.midToTrackID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sdpAnswer.isEmpty {
      try visitor.visitSingularStringField(value: self.sdpAnswer, fieldNumber: 1)
    }
    if !self.midToTrackID.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.midToTrackID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.SdpAnswer, rhs: Fishjam_MediaEvents_Server_MediaEvent.SdpAnswer) -> Bool {
    if lhs.sdpAnswer != rhs.sdpAnswer {return false}
    if lhs.midToTrackID != rhs.midToTrackID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.VadNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".VadNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "track_id"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 1)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.VadNotification, rhs: Fishjam_MediaEvents_Server_MediaEvent.VadNotification) -> Bool {
    if lhs.trackID != rhs.trackID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.VadNotification.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "STATUS_SILENCE"),
    2: .same(proto: "STATUS_SPEECH"),
  ]
}

extension Fishjam_MediaEvents_Server_MediaEvent.TrackVariantSwitched: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".TrackVariantSwitched"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "track_id"),
    3: .same(proto: "variant"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.variant) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 2)
    }
    if self.variant != .unspecified {
      try visitor.visitSingularEnumField(value: self.variant, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantSwitched, rhs: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantSwitched) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.trackID != rhs.trackID {return false}
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.TrackVariantDisabled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".TrackVariantDisabled"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "track_id"),
    3: .same(proto: "variant"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.variant) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 2)
    }
    if self.variant != .unspecified {
      try visitor.visitSingularEnumField(value: self.variant, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantDisabled, rhs: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantDisabled) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.trackID != rhs.trackID {return false}
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fishjam_MediaEvents_Server_MediaEvent.TrackVariantEnabled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Fishjam_MediaEvents_Server_MediaEvent.protoMessageName + ".TrackVariantEnabled"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "track_id"),
    3: .same(proto: "variant"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.variant) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 2)
    }
    if self.variant != .unspecified {
      try visitor.visitSingularEnumField(value: self.variant, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantEnabled, rhs: Fishjam_MediaEvents_Server_MediaEvent.TrackVariantEnabled) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.trackID != rhs.trackID {return false}
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
